IEEE TRANSACTIONS ON NEURAL NETWORKS AND LEARNING SYSTEMS, VOL. 31, NO. 9, SEPTEMBER 2020
# AlphaSeq: Sequence Discovery With Deep Reinforcement Learning
Yulin Shao , Student Member, IEEE, Soung Chang Liew , Fellow, IEEE, and Taotao Wang , Member, IEEE
Abstract— Sequences play an important role in many applica- tions and systems. Discovering sequences with desired properties has long been an interesting intellectual pursuit. This article puts forth a new paradigm, AlphaSeq, to discover desired sequences algorithmically using deep reinforcement learning (DRL) tech- niques. AlphaSeq treats the sequence discovery problem as an episodic symbol-ﬁlling game, in which a player ﬁlls symbols in the vacant positions of a sequence set sequentially during an episode of the game. Each episode ends with a completely ﬁlled sequence set, upon which a reward is given based on the desirability of the sequence set. AlphaSeq models the game as a Markov decision process (MDP) and adapts the DRL framework of AlphaGo to solve the MDP. Sequences discovered improve progressively as AlphaSeq, starting as a novice, and learns to become an expert game player through many episodes of game playing. Compared with traditional sequence construction by mathematical tools, AlphaSeq is particularly suitable for problems with complex objectives intractable to mathematical analysis. We demonstrate the searching capabilities of AlphaSeq in two applications: 1) AlphaSeq successfully rediscovers a set of ideal complemen- tary codes that can zero-force all potential interferences in multi-carrier code-division multiple access (CDMA) systems and 2) AlphaSeq discovers new sequences that triple the signal-to- interference ratio—benchmarked against the well-known Legen- dre sequence—of a mismatched ﬁlter (MMF) estimator in pulse compression radar systems.
Index Terms— AlphaGo, deep reinforcement learning (DRL), Monte Carlo tree search (MCTS), multi-carrier code-division multiple access (MC-CDMA), pulse compression radar.
sequences are critical components in many informa- tion systems. For example, cellular code-division multi- ple access (CDMA) systems make use of spread spectrum sequences to distinguish signals from different users [3]; pulse compression radar systems make use of probe pulses modu- lated by phase-coded sequences [4] to enable high-resolution detection of objects at a large distance.
Sequences in information systems are commonly designed by algebraists and information theorists using mathematical tools such as ﬁnite ﬁeld theory, algebraic number theory, and character theory. However, the design criterion for a good sequence may be complex and cannot be put into a clean mathematical expression for a solution by the available math- ematical tools. Faced with this problem, sequence designers may do the following two things.
- 1) Overlook the practical criterion and simplify the require- ments to make the problems analytically tractable. In so doing, a disconnect between reality and theory may be created.
- 2) Introduce additional but artiﬁcial constraints absent in the original practical problem. In this case, the analytical solution is only valid for a subset of sequences of interest. For example, the protocol sequences in [5] are constructed by means of the Chinese remainder theorem (CRT); hence, the number of supported users is restricted to a prime number.
# I. INTRODUCTION
A SEQUENCE is a list of elements arranged in a certain order. Prime numbers arranged in ascending order, for example, are a sequence [1]. The arrangements of nucleic acids in DNA polynucleotide chains are also sequences [2].
Discovering sequences with desired properties is an intel- lectual pursuit with important applications [1]. In particular,
Manuscript received October 3, 2018; revised January 14, 2019, May 1, 2019, and August 7, 2019; accepted September 16, 2019. Date of publication October 21, 2019; date of current version September 1, 2020. This work was supported in part by the General Research Funds established under the University Grant Committee of the Hong Kong Special Administrative Region, China, under Project 14200417. (Corresponding author: Soung Chang Liew.)
Y. Shao and S. C. Liew are with the Department of Information Engi- neering, The Chinese University of Hong Kong, Hong Kong (e-mail: sy016@ie.cuhk.edu.hk; soung@ie.cuhk.edu.hk).
T. Wang was with the Department of Information Engineering, The Chinese University of Hong Kong, Hong Kong. He is now with the College of Information Engineering, Shenzhen University, Shenzhen 518061, China (e-mail: ttwang@szu.edu.cn).
Color versions of one or more of the ﬁgures in this article are available online at http://ieeexplore.ieee.org.
Yet, a third approach is to ﬁnd the desired sequences algorithmically. This approach rids us of the conﬁnes imposed by analytical mathematical tools. On the other hand, the issue becomes whether good sequences can be found within a reasonable time by algorithms. Certainly, to the extent that desired sequences can be found by a random search algorithm within a reasonable time, then the problem is solved. Most desired sequences, however, cannot be found so easily, and algorithms with complexity polynomial in the length of the sequences are not available.
Reinforcement learning (RL) is an important branch of machine learning [6] known for its ability to derive solutions for Markov decision processes (MDPs) [7] through a learning process. A salient feature of RL is “learning from interac- tions.” Fig. 1 illustrates a framework of RL. In the framework, an agent interacts with an environment in a sequence of discrete-time steps. At time step t, the agent observes that the environment is in state st . Based on the observation of st , the agent then takes an action at , which results in the agent receiving a reward R(st +1) and the environment moving to
Digital Object Identiﬁer 10.1109/TNNLS.2019.2942951
2162-237X © 2019 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See https://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: University of London: Online Library. Downloaded on December 28,2024 at 23:12:31 UTC from IEEE Xplore. Restrictions apply.
3319
3320
IEEE TRANSACTIONS ON NEURAL NETWORKS AND LEARNING SYSTEMS, VOL. 31, NO. 9, SEPTEMBER 2020
action a, ¢ & state 5, 1 Sesi ao - reward R(S;41) Agent Environment
Fig. 1. Agent-environment interactions in RL. Given the observation that the environment is in state st , the agent follows its current policy and takes action at . The environment then moves to state st+1 and feedbacks a reward R(st+1) [6].
state st +1. RL framework can also be episodic, in which the agent-environment interactions are broken into sessions called episodes. The environment will feedback a reward R(sT ) only at a terminal state, i.e., at the end of one episode. The mapping from st to at is referred to as a policy function. The aim of the policy is to maximize the expected reward received at the end of the episode. This policy function could be deterministic, in which case a speciﬁc action at is always taken upon a given state st . The policy could also be probabilistic, in which case the action taken upon a given state is described by a conditional probability P(at |st ). The objective of the agent is to learn an expected reward maximizing policy after going through multiple episodes.1 The agent may begin with bad policies early on, but as it gathers experiences from successive episodes, the policy gets better and better.
The latest trend in RL research is to integrate the recent advances of deep learning [8] into the RL framework [9]–[11]. RL that makes use of deep neural networks (DNNs) to approx- imate the optimal policy function—-directly or indirectly—is referred to as deep RL (DRL). DRL allows RL algorithms to be applied when the number of possible state-action pairs is enormous and that traditional function approximators cannot approximate the policy function accurately. The recent success of DRL in game playing, natural language processing, and autonomous vehicle steering (see the excellent survey in [11]) has demonstrated its power in solving complex problems that thwart conventional approaches.
This article puts forth a DRL-based paradigm, referred to as AlphaSeq, to discover a set of sequences with desired properties algorithmically. The essence of AlphaSeq is as follows.
- 1) AlphaSeq treats sequence-set discovery—a sequence set consists of one or more sequences—as an episodic symbol-ﬁlling game. In each episode of the game, AlphaSeq ﬁlls symbols into vacant sequence positions in a consecutive manner until the sequence set is completely ﬁlled, whereupon a reward with a value between −1 and 1 is returned. The reward is a nonlinear function of a metric that quantiﬁes the desirability of the
1RL shares the same mathematical principle as that of dynamic program- ming (DP). To learn the optimal policy, RL algorithms typically contain two interacting processes: policy evaluation and policy improvement. We refer the reader to the exposition in [6], in which Section IV.1 explains how policy evaluation predicts the state-value function for an arbitrary policy, and Section IV.2 explains how policy improvement improves the policy with respect to the current state-value function. Overall, these two processes interact with each other as a generalized policy iteration (Section IV.6), enabling the convergence to the optimal value function and an optimal policy.
sequence set. AlphaSeq aims to maximize the reward. It learns to do by playing many episodes of the game, improving itself along the way.
- 2) AlphaSeq treats each intermediate state, with some sequence positions ﬁlled and others vacant in the game, as an image. Each position is a pixel of the image. Given an input state (image), AlphaSeq makes use of a DNN to recognize it and approximate the optimal policy that maximizes the reward. The DRL framework in AlphaSeq is adapted from AlphaGo [12], in which DNN-guided Monte Carlo Tree Search MCTS) is used to select each move in the game. As in AlphaGo, there is an iterative self-learning process in AlphaSeq in that the experiences from the DNN-guided MCTS game playing are used to train the DNN; and the trained DNN, in turn, improves future game playing by the DNN-guided MCTS.
- 3) We introduce two techniques in AlphaSeq that are absent in AlphaGo for our applications to search sequences. The ﬁrst technique is to allow AlphaSeq to make moves at a time (i.e., ﬁlling sequence positions at a time). Obviously, this technique is not applicable to the game of Go, hence AlphaGo. The choice of is a complexity tradeoff between the MCTS and the DNN. The second technique, dubbed “segmented induction,” is to change the reward function progressively to guide AlphaSeq toward good sequences in its learning process. In essence, we set a low target for AlphaSeq initially so that many sequence sets can have rewards close to 1, with few having rewards close to −1. As AlphaSeq plays more and more episodes of the game, we progressively raise the target so that fewer and fewer sequence sets have rewards close to 1, with more having rewards close to −1. In other words, the game becomes more and more demanding as AlphaSeq, starting as a novice, and learns to become an expert player.
We demonstrate the capability of AlphaSeq to discover two types of sequences. First, we use AlphaSeq to rediscover a set of complementary codes for multi-carrier (MC)-CDMA systems. In this application, AlphaSeq aims to discover a sequence set for which potential interferences in the MC-CDMA system can be canceled by simple signal process- ing. This particular problem already has analytical solutions. Our goal, here, is to test if AlphaSeq can rediscover these analytical solutions algorithmically rather than analytically. Second, we use AlphaSeq to discover new phase-coded sequences superior to the known sequences for pulse compres- sion radar systems. Speciﬁcally, our goal is to ﬁnd phase-coded sequences commensurate with the mismatched ﬁlter (MMF) estimator so that the estimator can yield an output with a high signal-to-interference ratio (SIR). The optimal sequences for MMF are not known and there is currently no known sequence that is provably optimal when the sequence is large. Bench- marked against the Legendre sequence [13], the sequence discovered by AlphaSeq triples the SIR, achieving 5.23-dB mean square error (MSE) gains for the estimation of radar
# cross sections in pulse compression radar systems.
The remainder of this article is organized as follows. Section II formulates the sequence discovery problem and
Authorized licensed use limited to: University of London: Online Library. Downloaded on December 28,2024 at 23:12:31 UTC from IEEE Xplore. Restrictions apply.
SHAO et al.: ALPHASEQ: SEQUENCE DISCOVERY WITH DRL
outlines the DRL framework of AlphaSeq. Sections III and IV present the applications of AlphaSeq in MC-CDMA systems and pulse compression radar systems, respectively. Section V concludes this article. Throughout this article, low- ercase bold letters denote vectors and uppercase bold letters denote matrices.
# II. METHODOLOGY
A. Problem Formulation
We consider the problem of discovering a sequence set C, the desirability of which is quantiﬁed by a metric M(C). Set C consists of K different sequences of the same length N, i.e., {ck : k = 0, 1, . . . , K − 1}, where the kth sequence is given by ck = (ck[0], ck[1], . . . , ck[N − 1]). Each symbol of the sequences in C (i.e., ck[n]) is drawn from a discrete set A. Without loss of generality, this article focuses on binary sequences. That is, A is two-valued, and we can simply denote these two values by 1 and −1. The metric function M(C) varies with application scenarios. It is generally a function of all K sequences in C. The optimal metric value M∗ (i.e., the desired metric value) is achieved when C = C∗. Our objective is to ﬁnd an optimal sequence set C∗ that yields M∗. For binary sequences, the complexity of the exhaustive search for C∗ is O(2N K ), which is prohibitive for large N and K .
This sequence discovery problem can be transformed into an MDP. Specifically, we treat sequence-set discovery as a symbol-filling game. One play of the game is one episode, and each episode contains a series of time steps. In each episode, the player (agent) starts from an all-zero state (i.e., all the symbols in the set are 0) and takes one action per time step based on its current action policy. In each time step, € symbols in the sequence set are assigned with the value of | or —1, replacing the original 0 value. We emphasize that the player can only determine the values of the € symbols but not their positions. The / positions are predetermined: a simple tule is to place symbols sequence by sequence (specifically, we first place symbols in one sequence). When this sequence is completed-filled, we turn to fill the next sequence, and so on and so forth. This rule will be used throughout this article unless specified otherwise). An episode ends at a terminal state after [NK/€] time steps, whereupon a complete set C is obtained. In the terminal state, we measure the goodness of C by M(C) and return a reward R(C) for this episode to the player, where R(C) is, in general, a nonlinear function of M(C). For this MDP, episodic RL can be used to learn a policy that makes sequential decisions to maximize the reward R(C). In a general RL setup, the agent’s objective at each state s; is to maximize the accumulated future reward >; yi Reş, where y is a discount factor. The MDP above, by contrast, restricts the reward to only terminal state since the guality of the seguence set cannot be evaluated until all the elements are fixed. This is a delayed reward setup, the goal at
state, and each vertex of the tree corresponds to a possible state, i.e., a partially ﬁlled sequence-set pattern (completely ﬁlled at a terminal state). The depth of the tree equals the number of time steps in an episode (i.e., N K /), and each vertex has exactly 2 branches. In each episode, the player will start from the root vertex and make sequential decisions along the tree based on its current policy until reaching a leaf vertex, whereupon a reward will be obtained. Given any vertex vi and an action, the next vertex vi+1 is conditionally independent of all previous vertices and actions, i.e., the transitions on the tree satisfy the Markov property.
The objective of the player is then to reach a leaf vertex with the maximum reward. Toward this objective, the player performs the following.
- 1) Distinguishing good states from bad states—A reward is given to the player only upon its reaching a termi- nal stage. Although traversing the intermediate stage, the player must distinguish good intermediate states from bad intermediate states so that it can navigate toward a good terminal stage. In particular, the player must learn to approximate the expected end rewards of intermedi- ate states: this is, in fact, a process of value function approximation (in RL, the value of a state refers to the expected reward of being in that state, and a value function is a mapping from states to values. For terminal states, the value function is exactly the reward function). Moreover, we can imagine each state to be an image with each symbol being a pixel and make use of a DNN to
approximate the expected rewards of the “images.”
- 2) Improving action policy based on cognition of subsequent states. Starting as a tabula rasa, the player’s initial policy in earlier episodes is rather random. To gradually improve the action policy, the player can leverage the instrument of MCTS. MCTS is a simulated look-ahead tree search. At a vertex, MCTS can estimate the prospects of subsequent vertices by simulating multiple actions along the tree. The information collected during the simulations can then be used to decide the real action to be taken at this vertex.2
A successful combination of DNN and MCTS has been demonstrated in AlphaGo [10], [12], [16], where the authors use DNN to assess the vertices during the MCTS simulation, as opposed to using random rollouts in standard MCTS [14]. In this article, we adapt the DRL framework in AlphaGo3 to solve the sequence set discovery problem associated with the underlying MDP. In deference to AlphaGo, we refer to this sequence discovering framework as “AlphaSeq.”
The overall algorithmic framework of AlphaGo/AlphaSeq can be outlined as an iterative “game-play with MCTS” and “DNN-update” process, as shown in Fig. 2. On the one hand,
each state is now to maximize the end-of-episode reward.
# B. Methodology
2The main concept in MCTS is tree policy. It determines how we sample the tree and select nodes. For a general overview on the core algorithms and variations, we refer the reader to the excellent survey [14] (in particular, the most popular algorithm in the MCTS family, the Upper Conﬁdence Bound for Trees (UCT), is introduced in Section III.3 of [14]). Reference [15] provides a more rigorous proof of the optimality of UCT. The authors showed that the probability that the UCT selects the optimal action converges to 1 at a polynomial rate.
Given the MDP, a tree can be constructed by all possible states in the game. In particular, the root vertex is the all-zero
3AlphaGo itself is evolving, the DRL framework in this article is based on AlphaGo Zero [12] and AlphaZero [16].
Authorized licensed use limited to: University of London: Online Library. Downloaded on December 28,2024 at 23:12:31 UTC from IEEE Xplore. Restrictions apply.
3321
3322
IEEE TRANSACTIONS ON NEURAL NETWORKS AND LEARNING SYSTEMS, VOL. 31, NO. 9, SEPTEMBER 2020
Higher-quality Experiences Game-play with MCTS DNN Update > Improved DNN >
Game-play with MCTS >
DNN Update >
# probabilistic policy TI(s;) (a distribution over all 2° possible
moves given by MCTS, not the raw policy estimation P of DNN) to choose symbols to ﬁll in the next positions in the sequence set. This action yields a new state si+1.
Fig. 2. Iterative algorithmic framework of AlphaGo/AlphaSeq. Improved DNN promotes the MCTS so that “game-play” generates experiences with higher quality; higher quality experiences can further enhance the DNN.

Fig. 3. Episode of game, where K = 2, N = 3, and / = 2. The NK positions are represented by colored squares: gray means that the positions are filled, while white means that the positions are vacant. At each time step, following the MCTS output TI, the player fills £ positions with value 1 or —1.
The bottom half of Fig. 3 shows the MCTS process at each state s;, where each circle (vertex) represents a possible state in the look-ahead search. In the MCTS for state s;, we first set the root vertex vp to be s; and initialize a “visited tree” (this visited tree is used to record all the vertices visited in the MCTS. It is initialized to have only one root vertex). Look-ahead simulations are then performed along the visited tree starting at the root vertex. Each simulation traces out a path of the visited tree and terminates when an unseen vertex vy is encountered. This unseen vertex will then be evaluated by DNN and added to the visited tree (i.e., a newly added vertex vz will be given the metric as wo(v_) = (PL, 1) to aid future simulations in evaluating which next move to select if the same vertex v; is visited again). As more and more simulations are performed, the tree grows in size. The metric used in selecting next move for the vertices will also change [i.e., (20) and (21) in Appendix A] as the vertices are visited more and more in successive simulations. In a nutshell, estimated good vertices are visited frequently, while estimated bad vertices are visited rarely. The resulting move-selection distribution at state sj, i.e., (si) = (70.71,....7x.)), is generated from the visiting counts of the root vertex’s children in MCTS at states 5;.
“game-play with MCTS” provides experiences to train the DNN so that the DNN can improve its assessments of the goodness of the states in the game. On the other hand, better evaluation on the states by the DNN allows the MCTS to make better decisions, which, in turn, provide higher quality experiences to train the DNN. Through an iterative process, the MCTS and the DNN mutually enhance each other in a progressive manner over an underlying RL process.
Back to the upper part of Fig. 3, after N K / time steps,
Back to the upper part of Fig. 3, after [NK /€] time steps, the player obtains a complete sequence set C with metric value M(C) that gives a reward R(C). Then, we feed the R(C) to each state s; in this episode and store (s;, I1(s;), R) as an experience. One episode of game-play gives us [NK /€] experiences.
In what follows, we dissect these two components and describe the relationship between them with more details. Differences between AlphaSeq and AlphaGo are presented at the end of this section. Further implementation details can be found in Appendix A.
1) Input and Output of DNN: The DNN is designed to esti- mate the value function and policy function of an intermediate state. The value function is the estimated expected terminal reward given the intermediate state. Speciﬁcally, the output of DNN can be expressed as ( P, R) = ψθ (si ): each time we feed an intermediate state si into the DNN ψ with coefﬁcients it will output a reward estimation R (value function θ , estimation) and a probabilistic move-selection policy P (policy function estimation, policy P is a distribution over all possible next moves given the current state si ).
2) Game-Play With MCTS: The ﬁrst part of the algorithm iteration in Fig. 2 is game-play with MCTS. As illustrated in Fig. 3, we play the game under the guidance of MCTS. The upper half of Fig. 3 presents all the states in an episode, where squares represent the positions in the sequence set: gray squares mean that the position has already been ﬁlled (with value 1 or −1); white squares mean that the position is still vacant (with value 0). The initial state of each episode is an all-zero state s0. In state si , the player will follow a
3) DNN Update: The second part of the algorithm iteration in Fig. 2 is the training of the DNN based on the accumulated experiences over successive episodes. First, from the descrip- tion above, we know that MCTS is guided by DNN. The capability of DNN determines the performance of MCTS since a better DNN yields more accurate evaluation of the vertices in MCTS. In the extreme, if the DNN perfectly knows which sequence-set patterns are good and which are bad, then the MCTS will always head toward an optimal direction, hence the chosen moves are also optimal. However, the fact is, DNN is randomly initialized, and its evaluation on vertices are quiet random and inaccurate initially. Thus, our goal is to improve this DNN using the experiences generated from game-play with MCTS.
In the process of DNN update, the DNN is updated by learning the latest experiences accumulated in the game-play. Given experience (s;, T(s;), R) and wo(s;) = (P, R’), 1) the real reward R can be used to improve the value-function approximation R’ of DNN and 2) the policy TI(s;) given by MCTS at state s; can be used to improve the policy estimation P(si) of DNN (policy TI(s;) is generally more powerful than the raw output P(s;) of DNN). Thus, the training process is to make P and R’ more closely match TI and R.
Remark: When we play games with MCTS to gener- ate experiences, the Dirichlet noise is added to the prior
Authorized licensed use limited to: University of London: Online Library. Downloaded on December 28,2024 at 23:12:31 UTC from IEEE Xplore. Restrictions apply.
SHAO et al.: ALPHASEQ: SEQUENCE DISCOVERY WITH DRL
probability of root node v0 to induce exploration, as that
in AlphaGo [12]. These games are also called noisy games. Instead of noisy games, we can also play noiseless games in which the Dirichlet noise is removed. Following the practice of AlphaGo, we play noisy games to generate the training experiences, but play noiseless games to evaluate the perfor- mance of AlphaSeq whose MCTS is guided by a particular trained DNN.
Overall, in one iteration, we: 1) play G episodes of noisy games with ψθ -guided MCTS to generate experiences, where ψθ is the current DNN; 2) use experiences gathered in the latest z × G episodes of games to train for a new DNN ψθ ; and 3) assess the new DNN ψθ by running 50 noiseless games with ψθ -guided MCTS.
In the next iteration, we generate further experiences by playing G episodes of noisy games with ψθ -guided MCTS. Then, these experiences are further used to train for yet another new DNN and so on and so forth. The pseudocode for AlphaSeq is given in Algorithm 1.
that is, the state at the beginning of the time step t has 2tl possible values. We found that imposing this restriction, while reducing complexity substantially, does not compromise the optimality of the sequence found.
- 2) In AlphaSeq, the choice of is a complexity tradeoff between MCTS and DNN; in AlphaGo, is always 1. As mentioned above, the universe of all states in the game forms a tree. The depth of the tree is N K /, which is the number of steps in Fig. 3 from left to right. This is exactly the number of MCTS we need to run in an episode. Thus, the larger the , the fewer the MCTS we need to run. On the other hand, large yields more legal moves (i.e., 2) in each state, hence burdening the DNN with a larger action space. Overall, given N and K , for small , for example, = 1, the mission of DNN is light since it only needs to determine to place 1 or −1 in the next position. However, the number of MCTS we need to run in an episode is up to N K . In contrast, for large , for example, = K , the number of MCTS we need to run in an episode is reduced to N, but the DNN is burdened with a heavier task because it needs to evaluate 2K possible moves for each state.

# Algorithm 1: AlphaSeq

# Initialization:
Initialize parameters z and DNN update cycle G. Initialize a DNN ψθ with parameter θ . Set episode g = 0.
# while 1 do
# Self-play to gain experience:


Play one episode of game, output each immediate state si , the corresponding (si ) given by MCTS, and the discovered sequence set C when this episode ends. Compute metric M(C) and reward R(C). ∀si , store (si , (si ), R(C)) as experience. g = g + 1.
# DNN update:
If mod(i, G) == 0 then Train DNN using the experiences accumulated in the latest z × G episodes, get new parameters θ . Assess current AlphaSeq with new parameters ψθ by playing 50 noiseless games. ψθ = ψθ . end
# end

In the following, we highlight some differences between AlphaSeq and AlphaGo.
- 1) In AlphaGo, the total number of legal states is O(3N K ) (in Go, N = K = 19; each position can be occupied by no stones, a white stone, or a black stone). If we allow AlphaSeq to ﬁll symbol positions in arbitrary order, then the complexity would be the same as AlphaGo in terms of the parameters N and K . However, for AlphaSeq, we impose the order in which symbol positions are ﬁlled to reduce complexity. Now, the number of legal states reduces to
INK/€)
>,
t =0
2t = 2N K + − 1
2 − 1

(1)
- 3) In the game of Go, the board is invariant to rotation and reﬂection. Thus, we should augment the training data to let DNN learn these features. Speciﬁcally, in AlphaGo Zero, each experience (board state and move distribution) can be transformed by rotation and reﬂection to obtain extra training data, and the state in an experience is randomly transformed before the experience is fed to the DNN [12]. On the other hand, in our game, no rotation or reﬂection is required because all positions are prede- termined. Any rotated or reﬂected state is an illegal state.
In the following sections, we demonstrate the searching capabilities of AlphaSeq in two applications: in Section III, we use AlphaSeq to rediscover an ideal complementary code set for MC-CDMA systems; and in Section IV, we use AlphaSeq to discover a new phase-coded sequence for pulse compression radar systems.
# III. REDISCOVER IDEAL COMPLEMENTARY CODE
# FOR MULTI-CARRIER CDMA
CDMA is a multiple-access technique that enables numerous users to communicate in the same frequency band simultaneously [3]. The fundamental principle of CDMA communications is to distinguish different users (or channels) by unique codes preassigned to them. Thus, CDMA code design lies at the heart of CDMA technology.
A. Codes in Legacy CDMA Systems
Existing cellular CDMA systems work on a one-code- per-user basis [3], [17]. For example, the code set designed such that exactly one code is assigned to each user, e.g., the orthogonal variable spreading factor (OVSF) is code set used in W-CDMA downlink, the m-sequence set used in CDMA2000 uplink, and the Gold sequence set used in W-CDMA uplink [18]. However, legacy CDMA systems are self-jamming systems since the code sets being used
Authorized licensed use limited to: University of London: Online Library. Downloaded on December 28,2024 at 23:12:31 UTC from IEEE Xplore. Restrictions apply.
3323
3324
IEEE TRANSACTIONS ON NEURAL NETWORKS AND LEARNING SYSTEMS, VOL. 31, NO. 9, SEPTEMBER 2020
<a The target signal bit 1X eq Tx ca -1xe4 @ axe, 1 | 1xe, || —ixe © 1xcg 11x ¢, 11x cq Potential - - Interferences © —ixeg |! 1xce |} ixep @ =1x cy} 1x cp! 1x cp
Fig. 4. Interferences caused by user asynchronies (misalignments of bit boundaries), multi-paths, and random signs of consecutive bits, in CDMA uplink. To decode user A’s data, the receiver correlates the received sig- nal with code cA. Interferences are induced by (a) cyclic autocorrelation of cA, (b) ﬂipped autocorrelation of cA, (c) cyclic cross correlation between cA and cB, and (d) ﬂipped cross correlation between cA and cB.
cannot guarantee user orthogonality under practical con- straints and considerations, such as user asynchronies, mul- tipath effects, and random signs of consecutive bits4 of user data streams [19].
In CDMA uplink, each user spreads its signal bits by modulating the assigned code, and the signals from multiple users overlap at the receiver. To decode a user A’s signal bit, as shown in Fig. 4, the receiver cross correlates the received signal with the locally generated code of user A. However, due to user asynchronies, multi-paths, and random signs in consec- utive bits, the correlation results can suffer from interferences introduced by multiple paths of user A’s signal or signal from another user B. The potential interferences can be computed by the correlations between the signal bit and two overlapping interfering bits: when the signs of the two interfering bits are the same, the interferences are cyclic correlation functions [i.e., Fig. 4(a) and (c)]; when the signs of the two interfering bits are different, the interferences are ﬂipped correlation functions [i.e., Fig. 4(b) and (d)]. On the other hand, CDMA downlink is a synchronous CDMA system and there are no asynchronies among signals of different users. However, multi-path and random signs in consecutive bits can still cause interferences through the above correlations among codes.
Mathematically, it has been proven that the ideal one-code- per-user code set that simultaneously zero forces the above correlation functions does not exist [20]. Code sets used in legacy CDMA systems tradeoff among these correlation functions. For example, the m-sequence set has nearly ideal cyclic autocorrelation property (to be exact, the autocorrelation function of the m-sequence is −1 for any nonzero shift, hence is “nearly” optimal), while its cyclic cross correlation func- tion (CCF) and ﬂipped correlation function are unbounded. The Gold sequence set and the Kasami sequence set (candidate in W-CDMA) have better cyclic cross correlation properties and acceptable cyclic autocorrelation properties, but their ﬂipped correlations are unbounded [18].
B. Multi-Carrier CDMA and Ideal Complementary Codes
The limitations of legacy CDMA systems motivate researchers to develop MC-CDMA (MC-CDMA) systems where complementary codes can be used to simultane- ously null all correlation functions among codes that may cause interferences [19].
The basic idea of complementary codes is to assign a ﬂock of M element codes to each user, as opposed to just one code in legacy CDMA systems. In MC-CDMA uplink [17], the signal bits of a user are spread by each of its M element codes and sent over M different subcarriers. When passing through the channel, the M subcarriers can be viewed as M separate virtual channels that have the same delay. The receiver ﬁrst despreads the received signal in each individual subcarrier (i.e., correlate the received signal in each subcarrier with the corresponding element code) and sums up the despreading outcomes of all M subcarriers. In other words, the operations in each individual channel are the same as legacy CDMA systems: the new step is the summing of the outputs of the M virtual channels, which cancels out the interferences induced by individual correlations in the underlying subcarriers.
To be speciﬁc, let us consider an MC-CDMA system with J users, where a ﬂock of M element codes of length N is assigned to each user. An ideal complementary code set C = {cm [n] : j = 0, 1, . . . , J − 1; m = 0, 1, . . . , M − 1; j n = 0, 1, . . . , N − 1} that can enable interference-free MC-CDMA systems is a code set that meets the following criteria simultaneously.
- 1) Ideal Cyclic Autocorrelation Function (CAF): For the M element codes assigned to a user j , i.e., {cm : m = 0, j 1, . . . , M − 1}, the sum of the CAF of each code is zero for any nonzero shift
M-1N-1 CAF;[v] = > Şiilerin +0] =0 (2) m=0 n=0
where delay (chip-level) v = 1, 2, .., N − 1. Hereinafter, the index additions in the square brackets refer modulo-N additions. to
- 2) Ideal CCF: For two ﬂocks of codes assigned to users j1 and j2, i.e., {cm , cm : m = 0, 1, . . . , M−1}, the sum of j1 j2 their CCFs is always zero irrespective of the relative shift
M-1N-1 CCF j,, j.[v] = > Şeiinlekln + v0 (3) m=0 n=0
where delay v = 0, 1, 2, .., N − 1 and j1 = j2.
- 3) Ideal Flipped Correlation Function (Fcf): For two ﬂocks of codes assigned to users j1 and j2, i.e., {cm , cm j1 j2 m = 0, 1, . . . , M −1}, the sum of their ﬂipped correlation : functions is always zero for any nonzero shift (ﬂipped correlation is only deﬁned for nonzero delay)
4In CDMA, “bit” refers to the baseband modulated information symbols (only BPSK/QPSK modulated symbols are considered in this article, in gen- eral, it can be shown that the codes discussed in this section are applicable for higher order modulations), while “chip” refers to the entries in the spread spectrum code. Thus, with respect to the nomenclature in Section II, “chips” in CDMA corresponds to “symbol” of a code sequence in Section II.
M-1[{N-v-1 FCF }j,, lo) = > > ci Inc} in +o] mol n=0 N-1 -> cimen 4vlf =0 (4) n=N-
Authorized licensed use limited to: University of London: Online Library. Downloaded on December 28,2024 at 23:12:31 UTC from IEEE Xplore. Restrictions apply.
(4)
SHAO et al.: ALPHASEQ: SEQUENCE DISCOVERY WITH DRL
where delay v = 1, 2, .., N − 1; j1 and j2 can be the same (ﬂipped autocorrelation function) or different (ﬂipped cross correlation function).
Some known mathematical constructions of ideal comple- mentary codes are available in [17]. In this section, we make use of AlphaSeq to rediscover a set of ideal complementary codes. Our aim is to investigate and evaluate the searching capability of AlphaSeq, i.e., whether it can rediscover an ideal complementary code set and how it goes about doing so. Furthermore, we would like to investigate the impact of the hyperparameters used in the search algorithm on the overall performance of AlphaSeq, so as to obtain useful insights for discovering other unknown sequences (e.g., in Section IV, we will make use of AlphaSeq to discover phase-coded sequences for pulse compression radar systems)
[see Appendix B for the derivation of maxC M(C)] and initialize the DNN to ψθ0 (i.e., the parameters in the DNN are randomly set to θ0) to play 50 noiseless games. Then, Mu is set as the mean metric of the 50 sequences found by these 50 noiseless games, i.e., Mu = E[M]. After this, Mu will not be changed anymore in future games. We specify that the initial games do not ﬁnd good sequences, but, nevertheless, the 50 sequences yield an E[M] much lower than maxC M(C). Using E[M] as Mu increases the slope of the ﬁrst line in (6).
Based on the metric function and reward function deﬁned above, we implemented AlphaSeq and trained DNN to redis- cover an ideal complementary code for MC-CDMA. A known ideal complementary code [17] is chosen as benchmark.
- 3) Benchmark: When J = 2, M = 2, and N = 8,
the ideal complementary code set exists. The mathematical constructions in [17] gives us
# C. AlphaSeq for MC-CDMA
In this section, we use AlphaSeq to rediscover an ideal complementary code set for MC-CDMA systems. As stated above, the ideal complementary code set is the code set that fulﬁlls the three criteria in (2)–(4). In this context, given a sequence set C, we deﬁne the following metric function to measure how good set C is for MC-CDMA systems.
⎛
⎞
[x +1 41 -1 41 41-1) 41] AH 1 41 41 41-1 -1 =I] Cbeneh — |r ar gn gt ag a a şi ij ) +1 -1 41 41 -1 41 41° 41]
As can be seen, there are J = 2 ﬂocks of codes in Cbench, each ﬂock contains M = 2 codes, and the length of each code is N = 8. It can be veriﬁed that M(Cbench) = 0.
1) Metric Function: For a sequence set C = {cm j j = 0, 1, . . . , J −1; m = 0, 1, . . . , M−1; n = 0, 1, . . . , N −1} [n] : consisting of M J sequences of the same length N, the metric function M(C) in the following reﬂects how good C is for MC-CDMA systems:
J-1N-1 J-1 M(C) = >) > ICAFjLoll + >, j=0 v= 1=0 > -1 N- N-1 SX Slcck pple J-1 =jit1 v=0 1 — J-1 >> A= ja=j, v=1 “ |FCF;,,p[ol]. | (5)
To rediscover the code set, there are 32 symbols to be ﬁlled in the game, and the number of all possible sequence-set patterns is 232 ≈ O(109). Discovering the global optimum out of O(109) possible patterns is, in fact, not a difﬁcult problem based on brute-force exhaustive search (even though it takes several days on our computer). The results of exhaustive search indicate that Cbench in (7) is not the only optimal pattern when J = 2, M = 2, and N = 8. There are in total 384 optimal patterns (that achieves M∗ = 0) that can be divided into 12 nonisomorphic types (i.e., each pattern has 31 other isomorphic patterns, see our technical report [21] for the speciﬁc shapes of isomorphic patterns).
Note that our desired metric value M∗ = inf M(C) = 0. For
AlphaSeq, the objective is then to discover the sequence set that minimizes this metric function.
As an essential part of the training paradigm in AlphaSeq, a reward function is needed to map a found sequence set C to a reward R(C). In general, we could design this reward function to be a linear (or nonlinear) mapping from the value range of the metric function to the interval [−1, 1]. This is, in fact, a normalization process to ﬁt general objectives to the architecture of AlphaSeq (speciﬁcally, normalizing the rewards of different problems allows these problems to share the same underlying hyperparameters in DNN and MCTS of the AlphaSeq architecture). To rediscover the ideal complementary code, we deﬁne the reward function as follows.
- 2) Reward Function: For any sequence set C with metric
M(C), the reward R(C) for MC-CDMA systems is deﬁned as
⎧
1 − 2M(C) ⎨ , If 0 ≤ M(C) ≤ Mu R(C) = Mu ⎩ −1, If M(C) > Mu
(6)
4) Implementation: We implemented and ran AlphaSeq on a computer with a single CPU (Intel Core i7-6700) and a single GPU (NVIDIA GeForce GTX 1080 Ti).5 The parameter settings are listed in Table I.
For the symbol ﬁlling game, we set K = M J = 4, N = 8,
and = 4. In other words, in each time step, four symbols were placed in the 4 × 8 sequence set, and an episode ended after N K / = 8 time steps when we obtained a complete sequence set. The metric function and reward function were then calculated following (5) and (6). An episode gave us eioght experiences.
For DNN-guided MCTS, at each state s;, we first set sj as the root node vo, and then ran g = 400 look-ahead simu- lations starting from vg. For each simulation, Dirichlet noise Dir(lao,aı,..., @¢_1]) was added to the prior probability of vg to introduce exploration, where the parameters for Dirichlet distribution are set as a0 = a Ont} a = 0.05. After 400 simulations, the probabilistic move-selection policy TI(s;) was then calculated by (22), where we set 7 = | for the
where [0, Mu] is the search range of M(C): when M(C) = Mu, then R(C) = −1; and when M(C) = 0, then R(C) = 1. We initially set Mu = maxC M(C)
5Given the listed computation resource, another experiment is presented in our technical report [21] to study the best found sequence versus time consumption in the RL process of AlphaSeq.
Authorized licensed use limited to: University of London: Online Library. Downloaded on December 28,2024 at 23:12:31 UTC from IEEE Xplore. Restrictions apply.
3325
3326
IEEE TRANSACTIONS ON NEURAL NETWORKS AND LEARNING SYSTEMS, VOL. 31, NO. 9, SEPTEMBER 2020
# TABLE I
# HYPERPARAMETERS OF ALPHASEQ FOR COMPLEMENTARY CODE DISCOVERY
Items Parameters Definitions K=4 Number of sequences in the target set The Designed gn: N=8 Length of each sequence Game £=4 Number of symbols filled in each time step q = 400 Number of simulations in one MCTS MCTS 40.05 Dirichlet noise 7 10-4 gr 1) Determines the way we calculate the move © selection policy based on their visiting counts Every G episodes, the DNN is updated using the experiences accumulated in the latest z x G episodes DNN Width of input image Length of input image batch = 64 Mini-batch size
ﬁrst one third time steps (the probability of choosing a move is proportional to its visiting counts), and τ = 10−4 for the rest of the time steps (deterministically choose the move with the most visiting counts).
The DNN implemented in AlphaSeq is a deep convolutional network (ConvNets). This DNN consists of six convolutional layers together with batch normalization and rectiﬁer nonlin- earities (detailed architecture of this ConvNets can be found in Appendix A). The DNN update cycle G = 100 and z = 3, that is, every G = 100 episodes, we trained the ConvNets using the experiences accumulated in the latest z × G = 300 episodes (i.e., 2400 experiences) by stochastic gradient descent. In particular, the minibatch size was set to 64, and we randomly sampled 2400/64 minibatches without replacement from the 2400 experiences to train the ConvNets. For each minibatch, the loss function is deﬁned by (23) in Appendix A.
saint 45 T T T T T 70 eee ew 4, see No. of visited States 60 a so ki 43, Ap 3 şek ML İzs? Hİ a i = yoy AlphaSeq (mean) 23 sop cal 4 < pry 2 c e... 15 20 / PİNPON DF DF DAP 0 Tam 2000-5000 4000 5000-060 od 3008 plsodes
saint
Fig. 5. RL process of AlphaSeq to rediscover a set of ideal complemen- tary codes for MC-CDMA systems. Mean metric E[M], minimum metric min[M], and the number of visited states versus episodes, where the DNN update cycle G = 100 and z = 3.
mance of current AlphaSeq. As a balance, we let AlphaSeq play 50 games so that a smoothed mean performance curve can be obtained without excessive evaluation time. The mean metric E[M] and the minimum metric min[M] of the 50 found sequence sets were recorded and plotted in Fig. 5. Note that the plots of metric and reward functions differ only in scale. We plot the metric evolution in Fig. 5 as it is a direct quality measurement of a sequence set in this speciﬁc application.
As can be seen from Fig. 5, with the continuous train- ing of DNN, AlphaSeq gradually discovered sequence sets with smaller and smaller metric values. After 4100 episodes, AlphaSeq rediscovered an ideal complementary code set Calpha given by
⎛
⎞
-141-1-141-1-1 al] 1-1-1 41 4141-141 Calpha = +1-1414+141-1-1-1] J ° (8) +1 4141-1 4141-141
Remark: In Table I, the width and length of the input image fed into DNN are chosen to match with N and K , i.e., K = K = 4 and N = N = 8. However, it should be emphasized that this is not an absolute necessity. In general, we ﬁnd that setting the input of the DNN to be an ×N K / image can speed up the learning process of DNN. For example, if we had set = 5 instead of = 4 in this experiment, then it would better to set K = 5 and N = 7 (i.e., DNN takes an 5 × 7 image as input, and in each time step, one row of the image is ﬁlled). Accordingly, any intermediate state (i.e., a partially ﬁlled 4 × 8 sequence set pattern) must ﬁrst be transformed to a 5×7 image before it is fed into the ConvNets (the last three symbols in the 5 × 7 set will be padded with 0 because the original 4 × 8 set has three fewer symbols).
# D. Performance Evaluation
Over the course of training, AlphaSeq ran 8 × 103 episodes, in which 6.4 × 104 experiences were generated. To monitor the evolution of AlphaSeq, every G = 100 episodes when the DNN was updated, we evaluated the searching capability of AlphaSeq by using it (with the updated DNN) to play 50 noise- less games. In general, the more evaluation games AlphaSeq plays, the better their mean performance captures the perfor-
It is straightforward to see that Calpha is an isomorphic version to Cbench: if we denote Cbench by ([a1, a2]T , i.e., [b1, b2]T )T , then Calpha = ([−b2, −b1]T , [a2, a1]T )T . We specify that AlphaSeq could ﬁnd different ideal sequence sets in different runs. For example, in another run, AlphaSeq eventually discovered a nonisomorphic ideal sequence set to Cbench, giving
⎛
⎞
| — -1 -1 1 -1 4l zl / -1 +1 41 41-1 -1 Şİ -1 alpha ~ | +1 -1 -1 41 41° 41 “| - O +1 -1 +1 41 41 41 410-1
The complexity of AlphaSeq is measured by means of distinct states that have been visited. Speciﬁcally, we stored all the states (including intermediate states and terminal states) encountered over the course of training in a Hash table. Every G episodes, we recorded the length of the Hash table (i.e., the total number of visited states by then) and plotted them in Fig. 5 as the training goes on.
An interesting observation is that there is a turning point on the curve of the number of distinct visited states. The slope of this curve corresponds to the extent to which AlphaSeq is exploring new states in its choice of actions. Under the framework of AlphaSeq, there are two kinds of explo- ration as follows.
Authorized licensed use limited to: University of London: Online Library. Downloaded on December 28,2024 at 23:12:31 UTC from IEEE Xplore. Restrictions apply.
SHAO et al.: ALPHASEQ: SEQUENCE DISCOVERY WITH DRL
- 1) Inherent Exploration: This is introduced by the variance of the action-selection policy. That is, the more random the action-selection policy is, the more new states are likely to be explored by AlphaSeq.
- 2) Artiﬁcial Exploration: We deliberately add extra artiﬁcial randomness to AlphaSeq to let it explore more states.
For example, the Dirichlet noise added to the root vertex in DNN-guided MCTS, the temperature parameter τ that deter- mines how to calculate the policy all add to the randomness. At the beginning of the game (i.e., episode 0), the policy of AlphaSeq is quite random inherently because the DNN is randomly initialized. Thus, both inherent exploration and artiﬁcial exploration contribute to the slope of this curve. At the end of the game (i.e., episode 8 × 103), the policy converges; hence, the inherent exploration drops off, and only artiﬁcial exploration remains.
20 F 40 Metric (AlphaSeq) 60 80 1 1 v 120 100 80 60 40 20 0 Metric (DNN player)
Fig. 6. Polynomial ﬁt convergence curve for AlphaSeq and DNN player, where the DNN update cycle G = 100. The positive direction of the x-axis is a direction of the performance improvement for DNN, while the positive direction of the y-axis is a direction of the performance improvement for AlphaSeq.
This turning point was, in fact, observed in all simu- lations of AlphaSeq in various applications we tried (not just the application for rediscovering complementary code here; see Section IV on application of AlphaSeq to dis- cover phase-coded sequences for pulse compression radar). In general, we can then divide the overall RL process of AlphaSeq into two phases based on this turning point. Phase I is an exploration-dominant phase (before the turning point), in which the behaviors of AlphaSeq are quite random. As a result, AlphaSeq actively explores increasingly more states per G episodes in the overall solution space. After gaining familiarity with the whole solution space, AlphaSeq enters an exploitation-dominant phase (after the turning point), in which instead of exploring for more states, AlphaSeq tends to focus more on exploitation.
i.e., P(si ), to sample the next move without relying on the
ie., P(s;), to sample the next move without relying on the MCTS outputs II(s;).
Fig. 6 shows all the (E[M], E[M]) pairs over the course
of training and the corresponding polynomial ﬁtted con- vergence curve. In particular, the positive direction of the x-axis in Fig. 6 is a direction of performance improvement for DNN, and the positive direction of y-axis is a direc- tion of performance improvement for AlphaSeq. The con- vergence curve in Fig. 6 reﬂects how the two ingredients, “MCTS-guided game-play” and “DNN update,” interplay and mutually improve in the RL process of AlphaSeq.
# IV. ALPHASEQ FOR PULSE COMPRESSION RADAR
Remark: The DNN update cycle G is important to guar- antee that the algorithmic iteration proceeds in a direction of performance improvement. In AlphaSeg, given a DNN wo, the move-selection policy TI given by the ye-guided MCTS is usually much stronger than the raw policy output P of yo. Thus, we first run yg-guided MCTS to play G games and generate | NK //) x G experiences. Then, we use these experiences to train a new DNN yy, so that yg: can learn the stronger move given by yp-guided MCTS.
In this context, the DNN update cycle G must be chosen so that the [VK/€] x G experiences are sufficient to capture the fine details of TI given by yp-guided MCTS. In particular, parameter G is closely related to /: a larger / means more elements in TI (i.e., TI must capture 2‘ possible moves in each step), and hence, a larger G is needed to guarantee that II is well represented by the (NK //| x G experiences.
As stated in Section II, the essence of AlphaSeq is a process of iterative “game-play with DNN-guided MCTS” and “DNN update”: the improvement of DNN brings about improvement of the DNN-guided MCTS, and the experiences generated by the improved MCTS, in turn, bring about further improvement of the DNN through training. To verify this, each time when the DNN is updated, we assess the new DNN by using it (without MCTS, and no noise) to discover 50 sequences and record their mean metric E[M]. Speciﬁcally, at each state si , the player directly adopts the raw policy output of the DNN,
Radar radiates radio pulses for the detection and loca- tion of reﬂecting objects [4]. A classical dilemma in radar systems arises from the choice of pulse duration: given a constant power, longer pulses have higher energy, providing greater detection range; shorter pulses, on the other hand, have larger bandwidth, yielding a higher resolution. Thus, there is a tradeoff between distance and resolution. Pulse compression radar can enable high-resolution detection over a large distance [4], [22], [23]. The key is to use modulated pulses (e.g., phase-coded pulse) rather than conventional non- modulated pulses.
A. Pulse Compression Radar and Phase codes
The transmitter of a binary phased-coded pulse compression radar system transmits a pulse modulated by N rectangular subpulses. The subpulses are a binary phase code s of length N. Each entry of the code is +1 or −1, corresponding to phase 0 and π. Following the deﬁnition in [23] and [24], after subpulse-matched ﬁltering (MF) and analog-to-digital conversion, the received sequence y is
N-1 y =hos + > hnJns kw (10) n=1—N,n40
where: 1) {hn : n = 1 − N, 2 − N, . . . , N − 2, N − 1} are coefﬁcients proportional to the radar cross sections of different
Authorized licensed use limited to: University of London: Online Library. Downloaded on December 28,2024 at 23:12:31 UTC from IEEE Xplore. Restrictions apply.
3327
3328
IEEE TRANSACTIONS ON NEURAL NETWORKS AND LEARNING SYSTEMS, VOL. 31, NO. 9, SEPTEMBER 2020
range bins [23]. In particular, h0 corresponds to the range bin of interest, and the radar’s objective is to estimate h0 given the received sequence y; 2) w is the white Gaussian noise; and 3) matrix Jn, as given in (11), is a shift matrix capturing the different propagation time needed for the clutter to return from different range bins [24].
Column; 0 1 2
where i = 1, 2, . . . , N−1 and J−i = J T . That is, in matrix Jn, i all entries except for that on the nth off-diagonal are 0. The effect of matrix Jn is to right-shift or left-shift the phase code s with zero padding: when n < 0, Jns is a right-shifted version of s; when n > 0, Jns is a left-shifted version of s.
To estimate the coefﬁcient h0, a widely studied estimator is the MF estimator [25]–[27]
(11)
received sequence, giving
T Nol T ~ xiy Xx Ins ho = = = ho+ > ln x's xls n=1-N,n#0 (14)
where the real-valued sequence x is to be optimized at the receiver. The problem is then to ﬁnd a pair of sequences (s, x) so that the SIR γMMF in (15) can be maximized
(Ts? Di (xT Ins)? n=1—N,n40 n YMMF = (15)
It had been shown in [24] that, given a phase code s, the optimal sequence x that maximizes γMMF is x∗ = R−1s, where matrix R is given by
N-1
R = JnssT J T n . (16) n=1−N,n=0
Substituting x∗ = R−1s in (15) gives
# γMMF = sT R−1s.
(17)
Note that γMMF only depends on the phase code s; hence, the objective for the design of the MMF estimator is then to discover a phase-code s that can maximize γMMF in (17).
N-1 ~ sly sl Ins ho = > =hot+ > hn — sis sis n=1-N.n#0 (12)
where the additive white Gaussian noise (AWGN) is ignored since the received signal is interference-limited (i.e., the inter- ference power dominates over the noise power). Given the fact that we have no information on {hn : n = 0}, the problem is then to discover a phase code s that can maximize the SIR γMF (larger SIR yields better estimation performance)
Remark: The MMF estimator is superior to the MF esti- mator since γMMF is not less than γMF given the same phase code s. However, the problem of discovering a phase code s that maximizes (17) did not receive much attention from the research community compared with the merit factor problem [i.e., discovering a code s that maximizes (15)]. This is perhaps due to the more complex criterion and the lack of suitable mathematical tools [27].
In this section, we make use of AlphaSeq to discover phase codes for pulse compression radar with MMF estimator.
(575) SAN Nazo (77,5) YMF = (13)
B. AlphaSeq for Pulse Compression Radar
We choose (17) as the metric function of AlphaSeq
In fact, this is the well-known “merit factor problem” occur- ring in various guises in many disciplines [26]. In the past few decades, a variety of phase codes have been devised to achieve large SIR (merit factor), e.g., the Rudin–Shapiro sequences (asymptotically, γMF = 3), m-sequences (asymp- totically, γMF = 3), and Legendre sequences (asymptotically, γMF = 6) (see the excellent surveys [26], [27] and the references therein). Overall, the merit factor problem remains open. Experiment results show that γMF does not increase as the sequence length N increases. So far, the best-known merit factor of 14.08 is achieved by the Barker sequence of length 13.
# M(s) = sT R−1s
(18)
where matrix R is given in (16). The objective of AlphaSeq is then to discover the sequence that can maximize this metric function.
Given a phase code s with metric M(s), the linear reward function is deﬁned as follows:
R(s) = 2M(s) − Mu − Ml Mu − Ml (19)
where Mu and Ml are the upper and lower bounds for the search range of M(s). In general, we could set Mu = maxs M(s) and Ml = mins M(s).
The motivation of the MF estimator comes from the fact that MF provides the highest signal-to-noise ratio (SNR) in the presence of white Gaussian noise [28]. However, in the case of Radar, the received signal is interference-limited; hence, inter- ference suppression is much more important. This motivates researchers to devise a MMF estimator [23], [24], [29].
Instead of using the transmitted phase-code s, the MMF estimator uses a general real-valued code x to correlate the
Remark: In Appendix C of our technical report [21], the value ranges of M(s) are derived as maxs M(s) = 37 and mins M(s) = (16/9N 3). However, we empirically the search range Mu = 37 ﬁnd that, if we directly set and Ml = (16/9N 3), AlphaSeq will be trapped in the exploration-dominant phase for a long time. This is because Mu −Ml is too large. In other words, we are asking AlphaSeq to search over a large solution space for s all at once. We will
Authorized licensed use limited to: University of London: Online Library. Downloaded on December 28,2024 at 23:12:31 UTC from IEEE Xplore. Restrictions apply.
SHAO et al.: ALPHASEQ: SEQUENCE DISCOVERY WITH DRL
# TABLE II
HYPERPARAMETERS OF ALPHASEQ FOR PHASE CODE DISCOVERY
Items Parameters Definitions K=1 Number of sequences in the target set The Designed |». 59 Length of each sequence Game 2-5 Number of symbols filled in each time step q = 900 Number of simulations in one MCTS MCTS a=0.1 Dirichlet noise 1 10-4 or 1) Determines the way we calculate the move ii selection policy based on their visiting counts G = 300 Every G episodes, the DNN is updated using the experiences accumulated in the latest z x z=2 G episodes DNN K'=5 Width of input image N'=12 Length of input image batch = 64 Mini-batch size
N K / = 12 time steps, where 60 symbols are obtained. Then, we ignore the last symbol and calculate the metric function and reward function following (18) and (19). The DNN update cycle G is set to 300 and z = 2. That is, every G = 300 episodes, DNN will be updated using the experiences accumulated in the latest 600 episodes.
Given the huge solution space, it is challenging for our computer to train AlphaSeq to ﬁnd the optimal solution. For one thing, each episode in this problem consumes much more time than the complementary code rediscovery problem in Section III, because of the larger number of MCTSs run in each episode and the larger number of simulations run in each MCTS. For another, the large solution space in this problem requires a massive number of exploration-dominant episodes so that AlphaSeq can visit enough number of states to gain familiarity with the whole solution space. As a result, the exploration phase will last a long time before AlphaSeq enters the exploitation phase. To tackle the above challenges, we use the following two techniques to accelerate the training process.
later introduce a technique dubbed “segmented induction” to induce AlphaSeq to zoomed-in view to a good solution. In essence, segmented induction uses a smaller range of [(16/9N 3), 37], but progressively changes Mu and Ml as better M(s) is obtained (i.e., focus our search within a subspace of s each time, but progressively changing the focus of the subspace within which we search).
Based on the metric function and reward function deﬁned above, we implemented AlphaSeq and trained DNN to dis- cover a phase code for the MMF estimator. A Legendre sequence [13] is chosen as the benchmark.
- 1) Make more efﬁcient use of experiences. Every G
- episodes, we trained the DNN using the experiences accumulated in the latest zG episodes (zGN K / experiences in total) by stochastic gradient descent. In Section III, the minibatches were randomly sampled without replacement. That gave us zGN K //64 minibatches (64 was the minibatch size). Here, we want to make more efﬁcient use of experiences. To this end, every G episodes, we randomly sample zGN K //64×6 minibatches with replacement from the latest zGN K / experiences to train the ConvNets.
1) Benchmarks: We choose the Legendre sequence of length N = 59 as our benchmark
⎡
+1 +1 −1 +1 +1 −1 +1 −1 +1 −1 −1 −1 sL = ⎢ ⎣ +1 −1 +1 +1 −1 +1 +1 +1 −1 +1 −1 +1 −1 −1 +1 −1 −1 +1 +1 +1 −1 +1 +1 +1 ⎥ ⎦ . +1 −1 −1 +1 +1 +1 +1 +1 −1 −1 −1 −1 −1 +1 +1 −1 −1 −1 −1 +1 −1 −1 −1
⎤
For the MMF estimator, this Legendre sequence yields SIR γMMF ≈ 10.98. For reference, sL yields a merit factor of γMF ≈ 6.19 when the MF estimator is used.
For the corresponding AlphaSeq game, there are 59 symbols to ﬁll. The number of all possible sequence-set patterns is 259. The complexity of the exhaustive search for the global optimum is O(1018), and it would take more than one million years for our computer to ﬁnd the optimal solution. In other words, the optimal solution of s when N = 59 is unavailable. In this context, the second benchmark we choose is a random search. For a random search, we randomly create 59-symbol sequences and record the maximum SIR obtained given a ﬁxed budget of random trials.
2) Implementation: In the AlphaSeq implementation, the parameter settings are listed in Table II. As seen in the table, we aim to discover one sequence of length 59 wherein K = 1 and N = 59 in the AlphaSeq game. The number of symbols ﬁlled in each time step is set to = 5, and the ConvNets takes 5×12 images as input. To feed an intermediate state (i.e., a partially ﬁlled 1 × 59 pattern) into the ConvNets, we ﬁrst transform it to a 5 × 12 image (the missing 1 symbol will be padded with 0). A complete sequence is obtained after
- 2) Segmented Induction: This technique is particularly use- ful when the upper and lower bounds of the metric function span a large range, or when there is no way to bound the metric function. The essence of segmented induction is to segment the large range of the metric function to several small ranges and deﬁne the linear reward in small ranges rather than in a single large range. To be more speciﬁc, assuming a metric function with values within the range [0, D]. Then, rather than initializing the search range Ml = 0 and Mu = D in (19), we segment [0, D] to three small overlapping ranges6 [0, D/2], [D/3, 2D/3], and [D/2, D] and deﬁne the linear reward in these small ranges: in episode 0, we deﬁne the reward function in the ﬁrst small range and initialize Ml = 0 and Mu = D/2. With the training of DNN, AlphaSeq is able to discover better and better sequences in the range [0, D/2]. When AlphaSeq discov- ers sequences with reward approaching 1 (i.e., the mean metric function of the found sequences approaches D/2), we then redeﬁne the reward with the second range [D/3, 2D/3]. That is, we set Ml = D/3, Mu = 2D/3, and let AlphaSeq discovers sequences in the second small range. When AlphaSeq is able to discover sequences
with reward approaching 1 again, we redeﬁne the reward
6a) Nonoverlapping intervals are inadvisable. Experimental results show that AlphaSeq cannot learn well when using nonoverlapping intervals. b) The small ranges segmented here are for illustration purpose only. In general, we need to design the ranges according to the speciﬁcs in different problems.
Authorized licensed use limited to: University of London: Online Library. Downloaded on December 28,2024 at 23:12:31 UTC from IEEE Xplore. Restrictions apply.
3329
3330
IEEE TRANSACTIONS ON NEURAL NETWORKS AND LEARNING SYSTEMS, VOL. 31, NO. 9, SEPTEMBER 2020
35 30 F 2k p Metric AphaSeqimesn) 42 No. of visited States Legendre (MMF) L L L L L 1 1 0 2000 4000 6000 8000 70000 — 72000 14000° Episodes

35 Random Search - = Legendre sequence 30 | |-B—AlphaSeg 10° 104 108 10° 107 10° 10° No. of visited States
Fig. 7. RL process of AlphaSeq to discover a phase-coded sequence for pulse compression radar. Mean metric E[M], maximum metric max[M], and a total number of visited states versus episodes, where the DNN update cycle G = 300 and z = 2.
Fig. 8. Searching capability comparison of AlphaSeq and random search. The AlphaSeq curve is the maximal metric max[M] versus the number of visited states.
in the third small range, and so on and so forth. Overall, with a smaller range at a given time, the slope of the reward function in (19) increases, allowing AlphaSeq to distinguish the relative quality of different sequences with higher contrast.
C. Performance Evaluation
For training, we ran AlphaSeq over 1.44 × 104 episodes, generating 1.73 × 105 experiences in total. As in Section III, to monitor the evolution of AlphaSeq, every G = 300 episodes when the DNN was updated, we evaluated the searching capability of AlphaSeq by using AlphaSeq (with the updated DNN) to play 50 noiseless games and recorded their mean metric E[M] and maximum metric max[M]. Fig. 7 shows the E[M] and max[M] versus episodes during the process of RL.
= = Legendre (MF) —G ~ Legendre (MMF) EH AlphaSeq (MMF) # g 10% 10° 10? 107 2 o
As can be seen, the ﬁrst 3300 episodes are the exploration-dominant phase and the episodes after that are the exploitation-dominant phase. After 1.26 × 104 episodes, AlphaSeq discovers a sequence with metric M(salpha) ≈ 33.45
⎡
+1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 salpha = ⎢ ⎣ +1 +1 +1 +1 −1 −1 −1 −1 −1 −1 −1 −1 +1 +1 +1 −1 −1 +1 +1 −1 +1 +1 −1 +1 ⎥ ⎦ . −1 −1 +1 −1 +1 −1 +1 −1 −1 +1 −1 +1 −1 +1 −1 +1 −1 +1 −1 +1 −1 +1 −1
⎤
Compared with the Legendre sequence, salpha triples the SIR at the output of an MMF estimator.
Remark: In this implementation, the value range of M(s),
i.e., [16/9N 3, 37] ≈ [0, 37], is segmented to three small ranges [0, 15], [5, 25], and [10, 37]. In the ﬁrst 8100 episodes, the linear reward is deﬁned in the ﬁrst small range [0, 15]: metric 0 corresponds to reward −1, and 15 corresponds to reward 1; from episode 8101 to 11400, the linear reward is deﬁned in the second small range [5, 25]; after episode 11401, the linear reward is deﬁned in the last small range [10, 37].
Fig. 9. MSE of salpha and sL for h0 estimation in pulse compression radar systems.
a transcription of two curves in Fig. 7: we combine the two curves, max[/M] versus episodes and number of visited states versus episodes, into one curve here. Fig. 8 also shows the maximal metric versus the number of visited states for random search.’ To get this curve, given a state-visit budget, we performed 20 runs of the experiments. For each run 7, we traced the maximum metric value obtained after a given number of random trials, denoted by Miax (nv), where n, is the number of trials, which correspond to the number of visited (terminal) states. The black curve in Fig. 8 is (1/20) ©; Mİ, (ny) (i.e., a mean-max curve).
# i
# max
As can be seen from Fig. 8, the largest metric that random search can ﬁnd is on average a log-linear function of the num- ber visited states. After randomly visiting 108 states, the best sequence random search can ﬁnd is on average with metric 11.71. On the other hand, AlphaSeq discovers sequences with max[M] = 33.45 after visiting only 4 × 107 states.
We next compare the searching capability of AlphaSeq with random search given the same complexity budget, where com- plexity is measured by the number of distinct visited states. For AlphaSeq, the visited states include both intermediate states and terminal states, while for a random search, only terminal states (i.e., completely ﬁlled sequences) will be searched.
Finally, we assess the estimation performance of salpha benchmarked against the Legendre sequence sL when used in a pulse compression radar system. In the simulation, we assume
7In our technique report [21], a deep Q-learning (DQL)-based approach, named DQLSeq, is developed to solve the MDP associated with the sequence discovery problem. The performance comparison between AlphaSeq and DQLSeq can be found in Appendix E of [21]. Overall, DQLSeq converges faster than AlphaSeq but is prone to getting stuck in local optimum.
In Fig. 8, the AlphaSeq curve is the maximal metric max[M] versus the number of visited states. This curve is
Authorized licensed use limited to: University of London: Online Library. Downloaded on December 28,2024 at 23:12:31 UTC from IEEE Xplore. Restrictions apply.
SHAO et al.: ALPHASEQ: SEQUENCE DISCOVERY WITH DRL
that the radar radiates pulse internally modulated by Saipha or sı. The received signal is given in (10), where (h,) are Gaussian random variables with zero mean and same vari- ance o?, and AWGN noise is ignored. The receiver estimates ho using an MMF estimator, and we measure the estimation performance by MSE e = (ho — ho)?. Fig. 9 shows MSE versus o? for Salpha and s1. As can be seen, Saipha Outperforms sı, and the MSE gains are up to about 5.23 dB.
# V. CONCLUSION
This article has demonstrated the power of DRL for sequence discovery. We believe that sequence discovery by DRL is a good supplement to sequence construction by mathe- matical tools, especially for problems with complex objectives intractable to mathematical analysis.
Our speciﬁc contributions and results are as follows.
- 1) We proposed a new DRL-based paradigm, AlphaSeq, to algorithmically discover a set of sequences with the desired property. AlphaSeq leverages the DRL framework of AlphaGo to solve an MDP associated with the sequence discovery problem. The MDP is a symbol-ﬁlling game, where a player follows a policy to consecutively ﬁll symbols in the vacant positions of a sequence set. In particular, AlphaSeq treats the intermediate states in the MDP as images and makes use of DNN to recognize them.
- 2) We introduced two new techniques in AlphaSeq to accel- erate the training process. The ﬁrst technique is to allow AlphaSeq to make moves at a time (i.e., ﬁlling sequence positions at a time). The choice of is a complexity tradeoff between the MCTS and the DNN. The second technique, dubbed segmented induction, is to change the reward function progressively to guide AlphaSeq to good sequences in its learning process.
- 3) We demonstrated the searching capabilities of AlphaSeq in two applications: 1) in MC CDMA systems, we used AlphaSeq to rediscover a set of ideal complementary codes that can zero-force all potential interferences and 2) in pulse compression radar systems, we used AlphaSeq to discover a new phase-coded sequence that triples the SIR at the output of a MMF estimator, benchmarked against the well-known Legendre sequence. The MSE gains are up to 5.23 dB for the estimation of radar cross sections.
# APPENDIX A
This appendix describes the implementation details of AlphaSeq. Other than some custom features for our purpose, the general implementation follows AlphaGo Zero [12] and AlphaZero [16]. The source code can be found at GitHub [30].
promising in the simulations, i.e., how to evaluate a vertex in MCTS. In standard MCTS algorithms, this vertex-evaluation is achieved by means of random rollouts. For example, for a new vertex encountered in each simulation, we run random rollout from this vertex to a leaf vertex such that a reward can be obtained (see [14] for more details). The randomly sampled rewards overall simulations are then used to evaluate a vertex.
In AlphaGo/AlphaSeq, instead of random rollouts, DNN is introduced to evaluate a vertex. The only two ingredients needed for MCTS are a root vertex v0 and a DNN ψθ . First, given the root vertex v0, a search tree can be constructed where each vertex contains 2 edges (since there are 2 possible moves for each state). Each edge, denoted by (vi , a j ), i = 0, 1, 2, . . . , j = 0, 1, 2, . . . , 2 − 1, stores three statistics: a visit count N(vi , a j ), a mean reward Q(vi , a j ), and an edge-selection prior probability P(vi , a j ). Second, MCTS uses DNN ψθ to evaluate each vertex (state). The input of ψθ is vi and the output is ( P, R) = ψθ (vi ). Speciﬁcally, each time we feed a vertex vi into the DNN, it outputs a policy estimation P and a reward estimation R. Each entry in distribution P is exactly the prior probability P(vi , a j ) for each edge of vertex vi , and R will be used for updating the mean reward Q(vi , a j ), given by (21) later.
MCTS is operated by means of look-ahead simulations. Speciﬁcally, at a root vertex v0, MCTS ﬁrst initializes a “visited tree” (this visited tree is used to record all the vertices visited in the MCTS. It is initialized to have only one root vertex) and runs q simulations on the visited tree. Each simulation proceeds as follows [12]:
1) Select: All the simulations start from the root vertex v0 and ﬁnish when a vertex that has not been seen is encountered for the ﬁrst time. During a simulation, we always choose the edge that yields a maximum upper conﬁdence bound. Speciﬁcally, at each vertex vi , the simulation selects edge j ∗ to visit, and
⎧
j ∗ = arg max j ⎨ ⎩Q(vi , a j )+c p P(vi , a j ) j N(vi , a j ) 1+ N(vi , a j ) ⎬ ⎭
where c p is a constant controls the tradeoff between explo- ration and exploitation.
2) Expand and Evaluate: When encountering a previ- ously unseen vertex v L (for the ﬁrst simulation, this v L in fact, v0), is, giving, ( PL , R L PL = {PL ( j ) : the simulation evaluates it using DNN, ) = ψθ (v L ), where the policy distribution j = 0, 1, 2, . . . , 2 − 1}. Then, we add this new vertex v L to the visited tree, and the statistics of v L ’s edges are initialized by N(v L , a j ) = 0, Q(v L , a j ) = 0, and P(v L , a j ) = PL ( j ) for j = 0, 1, 2, . . . , 2 − 1.
⎫
# A. MCTS
MCTS is performed at each intermediate state s; to deter- mine policy II(s;), and this is achieved by multiple look-ahead simulations along the tree. In the simulations, more promising vertices are visited frequently, while less promising vertices are visited less frequently. The problem is how to deter- mine which vertices are more promising and which are less
3) Backup: After adding vertex v L to the visited tree, the simulation updates all the vertices along the trajectory of encountering v L . Speciﬁcally, for each edge (vi , a j ) on the trajectory (including v L ), we update
N(vi , a j ) = N(vi , a j ) + 1
(20)
Q(vi , a j ) − R
Q(vi , a j ) = Q(vi , a j ) − N(vi , a j ) L . (21)
Authorized licensed use limited to: University of London: Online Library. Downloaded on December 28,2024 at 23:12:31 UTC from IEEE Xplore. Restrictions apply.
3331
3332
IEEE TRANSACTIONS ON NEURAL NETWORKS AND LEARNING SYSTEMS, VOL. 31, NO. 9, SEPTEMBER 2020
EE ee anl 1 ‘Cony Layer: 2 lere of size 1X1, side 1, same padding Input: 2 batch of KİN x3 images Cony Layer: | fier of ‘size 1X I, stride I, same padding Convolutional a 5 Unit 1 ; Batch Normalization Batch Normalization 13 T Rectifier Nonlinearity Rectifier Nonlinearity : ge cones ~ Convolutional! T T T Unit2 H FClayer:to a hidden FC layer: toa hidden İ i Rectifier Nonlinearity Convolutional | | Ban Normal, Batch Normalization T Unit 3 ; i 1 i Rector Nonlinear ect Nonlinearity : 1 : : | Felayertoa hidden Fe layer to aiden layer of 2 neurons, layer of 1 neuron, selamlar eee T P R Cony Layer: 256 iler ofsize 3% 3, stride 1 | Convolutional Unit 4
Fig. 10. Deep ConvNets implemented in AlphaSeq. This ConvNets consists of six convolutional layers together with batch normalization and rectiﬁer nonlinearities.
the K × N × 1 image, and X2(i, j ) = 0 elsewhere. The third
plane, X3, indicates the presentence of “0” in the K × N × 1 image: X3(i, j ) = 1 if the intersection (i, j ) has value “0” in the K × N × 1 image, and X3(i, j ) = 0 elsewhere.
3) Output: For each state si , DNN will output a policy estimation (i.e., a probability distribution) P(si ) = ( p0, p1,…, p2−1) as the prior probability for the 2 edges of si , and a scalar estimation R ∈ [−1, 1] on the expected reward of si .
4) Training: Every G games, we use the experiences accu- mulated in the most recent z × G games (i.e., zGN K / experiences) to update the DNN by stochastic gradient descent. The minibatch size is set to 64, and we randomly sample zGN K //64 minibatches without replacement from the zGN K / experiences to train the ConvNets. For each mini- batch, the loss function is deﬁned to minimize the summation of mean-squared error and cross-entropy loss [12]
After q simulations, MCTS then outputs a move selection probability for root vertex v0 by
TM (vo) = softmax | - log N(vo, ap} . (22)
# L=(R-RY — Hİ log P + cll ||
(23)
where the last term is L2 regularization to prevent overﬁtting. Over the course of training, the learning rate is ﬁxed to 10−4.
For example, the move selection probability is determined by the visiting counts of the root vertex’s edges. Parameter τ is a temperature parameter as in AlphaGo Zero [12]. In an episode, we set τ = 1 (i.e., the move-selection probability is proportional to the visiting counts of each edge, yielding more exploration) for the ﬁrst one third time steps and τ = 10−4 (deterministically choose the move that has the most visiting counts) for the rest of the time steps.
In the training iteration, when we play games to provide experiences for DNN, the Dirichlet noise, i.e., Dir([α0, α1, . . . , α ]) with positive real parameters α0, α1, . . . , α 2−1 is added to the prior probability of root node v0 to guarantee additional exploration. Thus, these games are called noisy games. Accordingly, there are noiseless games, in which the Dirichlet noise is removed. Generally, we play noiseless games to evaluate the performance of AlphaSeq with a trained DNN. 2−1,
# APPENDIX B
This section derives the supremum of M(C) in (5) in
Section III. Given the deﬁnitions of the correlation functions in (2)–(4), we ﬁrst rewrite (5) as follows:
J—1
J-1
N-1
J—1 J-1 N-1 MO DY) DY CCE), loll + PCE, teli) j0 fr=j) v=1 J—1 J-1 +> SY cer; lOll. (24) A=0 jra=fitl
For the second term in (24), we have
J-1
J-1
j1=0 j2= j1+1 |CCF j1, j2 [0]| ≤ J (J − 1) 2 N M. (25)
Moreover, the ﬁrst term in (24) can be simpliﬁed as follows:
# B. DNN
The DNN implemented in AlphaSeq is a deep convolutional network (ConvNets). This ConvNets consists of six convolu- tional layers together with batch normalization and rectiﬁer nonlinearities, the details of which are shown in Fig. 10.
- 1) Input: The ConvNets takes K × N × 3 image stack as
input. For a state si (i.e., an K × N partially ﬁlled sequence-set pattern), we ﬁrst transform it to a K × N × 1 image (in general, we set K = and N = N K /; zero-padding if K N > K N), and then perform feature extraction to trans- form it to a K × N × 3 image stack.
2) Feature Extraction: Feature extraction is a process to transform a K × N × 1 image to a K × N × 3 image stack comprising three binary feature planes. The three binary feature planes are constructed as follows. The ﬁrst plane, X1, indicates the presentence of “1” in the K × N × 1 image: X1(i, j ) = 1 if the intersection (i, j ) has value “1” in the K × N × 1 image, and X1(i, j ) = 0 elsewhere. The second plane, X2, indicates the presentence of “−1” in the K × N ×1 image: X2(i, j ) = 1 if the intersection (i, j ) has value “−1” in
J—1 J-1 N-1 DX DY CCE) lll + PCE; loll) A=0 joa=j) v=1 J—1 J-1 N-1 = DY) 5S davi + Atoll + lalol — Atoll) A=0 ja=j, v=1 J—1 J-1 N-1 = DD > 2max(latol, |All) ji=0 jo=ji v=
where a[v] = Mt Nol cl [nlc [n + ol, and Blo] = M-1~N-1 m m i m=0 Qan=N—» Gill + 0].
Note that set C is binary, hence, α[v] and β[v] are summa- tions of (N − v)M and v M terms of 1 or −1, respectively. As a result, we have
N-1 N-1 2 max(laloll, 181) < > 2max{(N — v)M,vM} v=1 3N7—4N41 v=1 M, for N odd 2 3N?—4N 2 M, for N even.
Authorized licensed use limited to: University of London: Online Library. Downloaded on December 28,2024 at 23:12:31 UTC from IEEE Xplore. Restrictions apply.
(24)
(26)
SHAO et al.: ALPHASEQ: SEQUENCE DISCOVERY WITH DRL
3333
Finally, we can bound M(C) from (25) and (26) as follows:
⎧
(3N 2 +1)(J 2+ J )−2N J (J +3) ⎪⎨ M, for N odd 4 M(C)≤ 3N 2(J 2 + J )−2N J (J +3) ⎪⎩ M, for N even. 4
The bounds can be achieved by an all −1 (or an all −1)
sequence set, hence is tight.
- [27] J. Jedwab, “What can be used instead of a Barker sequence?” Contemp. Math., vol. 461, pp. 153–178, Feb. 2008.
- [28] V.-P. Kaasila and A. Mammela, “Bit error probability of a matched ﬁlter in a Rayleigh fading multipath channel,” IEEE Trans. Commun., vol. 42, no. 234, pp. 826–828, Apr. 1994.
- [29] M. H. Ackroyd and F. Ghani, “Optimum mismatched ﬁlters for sidelobe suppression,” IEEE Trans. Aerosp. Electron. Syst., vol. AES-9, no. 2, pp. 214–218, Mar. 1973.
- [30] Y. Shao, S. C. Liew, and T. Wang. (2018). AlphaSeq: Sequence Discovery with Deep Reinforcement Learning. [Online]. Available: https://github.com/lintonshaw/AlphaSeq
# REFERENCES
- [1] OEIS. (1964). The On-Line Encyclopedia of Integer Sequences. [Online]. Available: https://oeis.org/A000040
- [2] J. M. Heather and B. Chain, “The sequence of sequencers: The history of sequencing DNA,” Genomics, vol. 107, no. 1, pp. 1–8, 2016.
- [3] A. J. Viterbi, CDMA: Principles of Spread Spectrum Communication, vol. 122. Reading, MA, USA: Addison-Wesley, 1995.
- [4] M. I. Skolnik, Radar Handbook. New York, NY, USA: McGraw-Hill, 2008.
- [5] Y. Chen, Y.-H. Lo, K. W. Shum, W. S. Wong, and Y. Zhang, “CRT sequences with applications to collision channels allowing successive interference cancellation,” IEEE Trans. Inf. Theory, vol. 64, no. 4, pp. 2910–2923, Apr. 2018.
- [6] R. S. Sutton and A. Barto, Reinforcement Learning: An Introduction. Cambridge, MA, USA: MIT Press, 2018.

Yulin Shao (S’17) received the B.E. and M.S. degrees from Xidian University (XDU), Xi’an, China, in 2013 and 2016, respectively. He is currently pursuing the Ph.D. degree with the Department of Information Engineering, The Chinese University of Hong Kong (CUHK), Hong Kong.
He was a Research Assistant with the Institute of Network Coding, CUHK, from March 2015 to August 2016. He was a Visiting Scholar with the Research Laboratory of Electronics, Massachusetts
- [7] M. L. Puterman, Markov Decision Processes: Discrete Stochastic Dynamic Programming. Hoboken, NJ, USA: Wiley, 2014.
- [8] Y. LeCun, Y. Bengio, and G. Hinton, “Deep learning,” Nature, vol. 521, no. 7553, p. 436, 2015.
Institute of Technology, Cambridge, MA, USA, from September 2018 to March 2019. His current research interests include signal processing, fundamentals of wireless communications and networking, and machine learning (deep reinforcement learning, in particular).
- [9] V. Mnih et al., “Human-level control through deep reinforcement learn- ing,” Nature, vol. 518, no. 7540, p. 529, 2015.
- [10] D. Silver et al., “Mastering the game of go with deep neural networks and tree search,” Nature, vol. 529, no. 7587, pp. 484–489, 2016.
- [11] Y. Li, “Deep reinforcement learning: An overview,” arXiv:1701.07274. [Online]. Available: https://arxiv.org/abs/1701.07274 2017,
- [12] D. Silver et al., “Mastering the game of go without human knowledge,” Nature, vol. 550, no. 7676, p. 354, 2017.
- [13] M. Golay, “The merit factor of Legendre sequences (corresp.),” IEEE Trans. Inf. Theory, vol. IT-29, no. 6, pp. 934–936, Nov. 1983.
- [14] C. B. Browne et al., “A survey of Monte Carlo tree search methods,” IEEE Trans. Comput. Intell. AI Games, vol. 4, no. 1, pp. 1–43, Mar. 2012.
- [15] L. Kocsis and C. Szepesvári, “Bandit based Monte-Carlo planning,” in Proc. Eur. Conf. Mach. Learn. Berlin, Germany: Springer, 2006, pp. 282–293.

Soung Chang Liew (S’84–M’87–SM’92–F’12) received the S.B., S.M., E.E., and Ph.D. degrees from the Massachusetts Institute of Technology (MIT), Cambridge, MA, USA.
From 1984 to 1988, he was with the MIT Laboratory for Information and Decision Systems, Cambridge, where he investigated ﬁber-optic communications networks. From March 1988 to July 1993, he was with Bellcore (now Telcordia), Piscataway, NJ, USA, where he engaged in broad- band network research. Since 1993, he has been
- [16] D. Silver et al., “Mastering chess and shogi by self-play with a general reinforcement learning algorithm,” 2017, arXiv:1712.01815. [Online]. Available: https://arxiv.org/abs/1712.01815
- [17] H. H. Chen, The Next Generation CDMA Technologies. Hoboken, NJ, USA: Wiley, 2007.
- [18] J. M. Velazquez-Gutierrez and C. Vargas-Rosales, “Sequence sets in wireless communication systems: A survey,” IEEE Commun. Surveys Tuts., vol. 19, no. 2, pp. 1225–1248, 2nd Quart., 2017.
a Professor with the Department of Information Engineering, The Chinese University of Hong Kong (CUHK), Hong Kong. He is currently the Division Head of the Department of Information Engineering and a Co-Director of the Institute of Network Coding with CUHK. He is also serving as a Board Member for the Hong Kong Applied Science and Technology Institute (ASTRI), Hong Kong. He holds 15 U.S. patents. His current research interests include wireless networks, Internet of Things, intelligent transport systems, Internet protocols, multimedia communications, and packet switch design.
- [19] H.-H. Chen, J.-F. Yeh, and N. Suehiro, “A multicarrier CDMA archi- tecture based on orthogonal complementary codes for new generations of wideband wireless communications,” IEEE Commun. Mag., vol. 39, no. 10, pp. 126–135, Oct. 2001.
Dr. Liew is a fellow of IET and HKIE. He was a recipient of the ﬁrst Vice-Chancellor Exemplary Teaching Award in 2000 and the Research Excellence Award in 2013 at the Chinese University of Hong Kong.
- [20] L. Welch, “Lower bounds on the maximum cross correlation of signals (Corresp.),” IEEE Trans. Inf. Theory, vol. IT-20, no. 3, pp. 397–399, May 1974.
- [21] Y. Shao, S. C. Liew, and T. Wang, “AlphaSeq: Sequence discov- ery with deep reinforcement learning,” 2018, [Online]. Available: https://arxiv.org/abs/1810.01218
- [22] A. Boehmer, “Binary pulse compression codes,” IEEE Trans. Inf. Theory, vol. IT-13, no. 2, pp. 156–167, Apr. 1967.
- [23] R. M. Davis, R. L. Facnte, and R. P. Perry, “Phase-coded waveforms for radar,” IEEE Trans. Aerosp. Electron. Syst., vol. 43, no. 1, pp. 401–408, Jan. 2007.
- [24] P. Stoica, J. Li, and M. Xue, “On sequences with good correlation properties: A new perspective,” in Proc. IEEE Inf. Theory Workshop (ITW), Jul. 2007, pp. 1–5.
- [25] M. Golay, “The merit factor of long low autocorrelation binary sequences,” IEEE Trans. Inf. Theory, vol. IT-28, no. 3, pp. 543–549, May 1982.
- [26] T. Høholdt, “The merit factor problem for binary sequences,” in Proc. Int. Symp. Appl. Algebra, Algebr. Algorithms, Error-Correcting Codes (AAECC). Berlin, Germany: Springer, 2006, pp. 51–59.
a
Taotao Wang (M’16) received the B.S. degree in electrical engineering from the University of Elec- tronic Science and Technology of China, Chengdu, China, in 2008, the M.S. degree in information and signal processing from the Beijing University of Posts and Telecommunications, Beijing, China, in 2011, and the Ph.D. degree in information engi- neering from The Chinese University of Hong Kong (CUHK), Hong Kong, in 2015.
From 2015 to 2016, he was a Post-Doctoral Research Fellow with the Institute of Network Cod- ing, CUHK. He joined the College of Information Engineering, Shenzhen University, Shenzhen, China, as an Assistant Professor. His current research interests include wireless communications and networking, statistical signal and data processing, and blockchain networks.
Dr. Wang was a recipient of the Hong Kong Ph.D. Fellowship.
Authorized licensed use limited to: University of London: Online Library. Downloaded on December 28,2024 at 23:12:31 UTC from IEEE Xplore. Restrictions apply.
